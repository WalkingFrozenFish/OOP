// Процедурный подход в программировании
const width1 = 5;
const height1 = 10;

function calcRectArea1(width1, height1) {
    return width1 * height1;
}

calcRectArea1(width1, height1);


// ООП
// Класс - это набор характеристик, которые описывают некоторую сущность
// К примеру класс "Человек", этот класс обладает такими характеристиками как Имя, Фамилия, Возраст, Вес, Рост. Они характеризуют некоторую сущность, то есть в данном сучае человека

// Объект - экземлпяр класса, обладает уже определенными значениями в характеристиках
// К примеру объект "Василий", это экземпляр класса "Человек". У данного экземпляра есть значения в характеристиках, то есть Имя - Вася, Фамилия - Пупкин, Возраст - 27, Вес - 70, Рост - 80

// Свойства - это все те характеристики Имя, Фамилия, Возраст, Вес, Рост

// Методы - это все те действия, которые может делать объект, к примеру Рисовать, Ходить, Кодить, Говорить


// Класс Прямоугольник
class Rectangle {
    // У класса есть свойства, ширина и высота
    width;
    height;

    // У каждого класса есть конструктор, это специальный метод, некоторый блок инструктций, который будет вызван при создании объекта. Он может принимать аргументы. Обычно в конструкторе свойствам объекта присваиваются какие то значения. В данном случае мы принимаем аргументами высоту и ширину, и сохраняем их
    constructor(w, h) {
        this.width = w;
        this.height = h;
    }

    // Так же есть метод для вычисления площади прямоугольника
    // В классах может быть сколько угодно методов
    calcArea() {
        // Под this, подразумевается объект у которого будет вызван этот метод
        return this.width * this.height;
    }

    calcPerimetr() {
        return (this.height + this.width) * 2;
    }
}

// С помощью оператора new, мы можем создать объект, то есть отдельный экземпляр класса.
// Передаем аргументами высоту и ширину
const rect = new Rectangle(5, 10);

// У созданного объекта, мы можем вызвать соответствующий метод, который вернет площадь объекта, у которого мы вызвали этот метод
rect.calcArea()

// Так же можно создать сколько угодно объектов из любого класса
// В данном примере, у каждого прямоугольника своя высота и ширина
const rect1 = new Rectangle(15, 20);
console.log("Area - rect1", rect1.calcArea());
console.log("Perimetr - rect1", rect1.calcPerimetr());

const rect2 = new Rectangle(25, 12);
console.log("Area - rect2", rect2.calcArea());
console.log("Perimetr - rect2", rect2.calcPerimetr());

const rect3 = new Rectangle(10, 42);
console.log("Area - rect3", rect3.calcArea());
console.log("Perimetr - rect3", rect3.calcPerimetr());



// ООП базируется на трех основных концепциях "Инкапсуляция", "Наследование", "Полиморфизм"
// Инкапсуляция - Класс, это своего рода капсула, которая хранит в себе свойства и методы для работы с этими самыми свойствами. То есть класс объединяет это все вместе.

// Сокрытие - К примеру возьмем класс "Человек", у этого класса есть такие свойства как "Имя", "Фамилия", "Возраст" и методы "Писать код", "Говорить", "Ходить", "Рисовать". Эти свойства и методы публичные, и их использование в любом месте кода, не нарушит логику программы.

// Помимо публичных свойств и методов есть закрытая часть, приватная. Это та часть с которой мы не можем работать и как то повлиять извне. К примеру класс "Человек", у человека есть приватные методы "Перекачивание крови", "Переваривание пищи", "Обработка информации", это скрытая часть, которая находится внутри человека, та часть на которую мы не можем повлиять как то извне.

// Существуют модификаторы доступа public и private, они позволяют делать свойства и методы публичными или приватными. Свойства и методы с модификатором private, можно использовать только внутри класса, вызвать их извне нельзя

// К примеру возьмем подключение к базе данных. В классе присутствую поля url и port. Для того что бы никто не смог поменять url, у этого свойства устанавливается модификатор доступа private. Единственный способ установки значения, это конструктор класса, то есть устанавливаем значения при создании экземпляра класса, и забываем

class Rectangle1 {
    // private ключевое слово, доступно в typescript
    // Теперь поля высоты и ширины приватные, обратиться к ним извне теперь нельзя
    // Нижнее подчеркивание, это соглашение между разработчиками, о том что данное поле приватное
    private _width;
    private _height;

    constructor(w, h) {
        this._width = w;
        this._height = h;
    }

    // Для того что бы получать доступ к этим свойствам (получать и изменять), используются геттеры и сеттеры
    // В данном случае, при вызове геттера, мы просто вернем ширину объекта
    get width() {
        // Внутри класса и методов, мы можем обращаться к приватным свойствам данного класса
        // this._height;
        return this._width;
    }

    // В случае с сеттером, мы можем присвоить новое значение, либо сделать дополнительные действия
    // Если явно не указывать модификатор доступа, он будет по умолчанию public
    set width(value) {
        if (value <= 0) {
            this._width = 1;
        } else {
            this._width = value;
        }
    }
}

const rect4 = new Rectangle1(5, 10);
// В данном случае мы не сможем обратиться к высоте, так как свойство приватное, и для него не созданы геттеры и сеттеры
// rect4.height();
console.log("Геттер", rect4.width);



// Пример
// Создание класса User
class User {
    // Объявление приватных свойств у класса
    private _username;
    private _password;
    private _id;

    // Имя и пароль мы получаем при создании эуземпляра класса
    constructor(username, password) {
        this.username = username;
        this.password = password;
        // this._id = generateRandomId();
    }

    // Для получения и изменения значений, создаем геттеры и сеттеры
    get username() {
        return this._username;
    }

    set username(value) {
        this._username = value;
    }

    get password() {
        return this._password;
    }

    set password(value) {
        this._password = value;
    }

    get id() {
        return this._id;
    }
}

// Создание экземпляра класса
const user = new User("username", "password");

// Ошибка, так как поле id доступно только для чтения
// user.id = 10;

// Так как мы создали сеттеры и геттеры, мы можем получить доступ к приватным свойствам
user.username = "user";
user.password = "123";



// Пример
// Создание класса
class Database {
    // Объявление приватных свойств
    private _url;
    private _port;
    private _username;
    private _password;
    private _tables;

    // Значения свойств мы присваиваем внутри конструктора
    constructor(url, port, username, password) {
        this._url = url;
        this._port = port;
        this._username = username;
        this._password = password;
        this._tables = [];
    }

    // Публичный метод, с помощью которого мы добавляем таблицы в массив
    public createNewTable(table) {
        this._tables.push(table);
    }

    // Публичный метод для удаления таблиц из массива
    public clearTables() {
        this._tables = [];
    }

    // Геттеры
    get url() {
        return this._url;
    }

    get port() {
        return this._port;
    }

    get username() {
        return this._username;
    }

    get password() {
        return this._password;
    }

    get tables() {
        return this._tables;
    }
}

// Создание экземпляра класса, в который мы передаем данные
const db = new Database(1, 2, 3, 4);

// Ошибка, приватное свойство
// db.tables = [];

// С помощью публичных методов, мы добавляем данные в массив
db.createNewTable({ "user": "1" });
db.createNewTable({ "data": "2" });

// Так же удаляем данные из массива
db.clearTables();

// Данные примеры показывают работу инкапсуляции и сокрытия. Они позволяют объявлять приватные свойства и методы, которые не доступны извне. Получение доступа к приватным свойствам с помощью геттеров и сеттеров.



// Наследование - основная концепция, где классы могут наследовать определенные свойства и методы других классов.

// К примеру у нас есть класс "Человек", у этого класса есть свойства, такие как Имя, Фамилия, Возраст. Эти свойства присущи классу "Человек". Другие данные этому классу не требуются

// Далее, у нас есть класс "Работник", у этого класса есть собственные свойства, такие как ИНН, СНИЛС, Серия, Номер паспорта. Эти свойства присущи классу "Работник". Так же класс "Работник" наследует свойства класса "Человек", другими словами, класс "Работник" расширяет класс "Человек".

// Еще у нас есть класс "Разработчик", у него есть собственные свойства, такие как Язык программирования, уровень. И он так же наследует свойства "Человек" и "Работник".


// Создаем класс "Person"
class Person {
    // Определяем свойства
    private _firstName;
    private _lastName;
    private _age;

    // Объявляем конструктор, куда передаем свойства
    constructor(firstName, lastName, age) {
        this._firstName = firstName;
        this._lastName = lastName;
        this._age = age;
    }

    // Пример полиморфизма
    public greeting() {
        console.log(`Привет, я человек, и меня зовут ${this._firstName}`);
    }

    // Создаем геттер для получения имени и фамилии
    public get fullName() {
        return `Фамилия - ${this._lastName} Имя - ${this._firstName}`;
    }

    get firstName() {
        return this._firstName;
    }

    set firstName(value) {
        this._firstName = value;
    }

    get lastName() {
        return this._lastName;
    }

    set lastName(value) {
        this._lastName = value;
    }

    get age() {
        return this._age;
    }

    set age(value) {
        if (value < 0) {
            this._age = 0;
        } else {
            this._age = value;
        }
    }
}

// Создаем класс "Employee", который будет наследовать свойства и методы родительского класса
class Employee extends Person {
    // Объявляем свойства данному классу
    private _inn;
    private _number;
    private _snils;

    // При наследовании, по умолчанию будет наследован родительский конструктор
    constructor(firstName, lastName, age, inn, number, snils) {
        // Сперва будет вызван родительский конструктор, и только потом выполнять в данном классе какие то действия
        // Сперва объявляем через ключевое слово super, родительский конструктор
        super(firstName, lastName, age);
        this._inn = inn;
        this._number = number;
        this._snils = snils;
    }

    // Пример полиморфизма, переопределяем метод родительского класса
    greeting() {
        console.log(`Привет, я работник, и меня зовут ${this.firstName}`)
    }
}

// Создаем экземпляр класса "Employee", куда передаем свойства Имя, Фамилия, Возраст, данные свойства унаследованы от родительского класса. Затем передаем другие данные, которые определены в классе "Employee"
const employee1 = new Employee("Name", "Last name", 20, 123, 432, 12341234);
console.log(employee1);

// Так же мы можем вызывать методы родительского класса
console.log(employee1.fullName);

// Создаем класс "Developer", который будет наследовать свойства и методы родительского класса
class Developer extends Employee {
    // Определяем свойства класса
    private _level;
    private _language;

    // В конструктор передаем значения родительского класса и текущего класса
    constructor(firstName, lastName, age, inn, number, snils, level, language) {
        // Объявляем конструктор родительского класса
        super(firstName, lastName, age, inn, number, snils);
        this._level = level;
        this._language = language;
    }

    // Пример полиморфизма, переопределяем родительский метод
    greeting() {
        console.log(`Привет, я разработчик, и меня зовут ${this.firstName}`)
    }
}

// Создаем экземпляр класса "Developer"
const developer1 = new Developer("DevName", "DevLastName", 23, 12341234, 4321, 123512351251235, "Senior", "JS");

console.log(developer1);
// Вызываем свойства, которые были определены в родительском классе
console.log(developer1.fullName);



// Полиморфизм - в контексте ООП, это некоторый принцип, который позволяет работать одному и тому же коду с разными типами данных
// Выделяют два вида полиморфизма, это ad-hoc и параметрический

// Ad-hoc - мнимый полиморфизм. Позволяет использовать один метод, но с разными типами данных

// class Calculator {
//     add(a: number, b: number): number {
//         return a + b;
//     }

//     add(a: string, b: string): string {
//         return a + b;
//     }
// }

// let cl1 = new Calculator();
// let cl2 = new Calculator();
// cl1.add(1, 1);
// cl2.add("1", "1");


// Параметрический - Представим что в комнате есть три объекта, человек, работник и программист. Мы должны сделать так, что бы они поздоровались.
// Привет, я человек
// Привет, я работник
// Привет, я программист

// Для этого мы будем использовать один и тот же метод

// Метод, который мы объявили в родительском классе, и потом переопределили его в дочерних классах. То есть один и тот же метод но работает с разными типами данных
// public greeting() {
//      console.log(`Привет, я человек, и меня зовут ${this._firstName}`);
// }

// Создаем три объекта
const dev1 = new Developer("fnDev", "lnDev", 23, 123, 321, 3123123, "Junior", "JS");
const emp1 = new Employee("fnEmp", "lnEmp", 23, 123312, 412, 124124);
const per1 = new Person("fnPer", "lnPer", 23);

// У каждого есть родительский метод
dev1.greeting();
emp1.greeting();
per1.greeting();

// Лог до переопределения метода
// Привет, я человек, и меня зовут fnDev
// Привет, я человек, и меня зовут fnEmp
// Привет, я человек, и меня зовут fnPer

// Лог после переопределения метода
// Привет, я разработчик, и меня зовут fnDev
// Привет, я работник, и меня зовут fnEmp
// Привет, я человек, и меня зовут fnPer