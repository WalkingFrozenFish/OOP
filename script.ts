// Процедурный подход в программировании
const width = 5;
const height = 10;

function calcRectArea(width, height) {
    return width * height;
}

calcRectArea(width, height);


// ООП
// Класс - это набор характеристик, которые описывают некоторую сущность
// К примеру класс "Человек", этот класс обладает такими характеристиками как Имя, Фамилия, Возраст, Вес, Рост. Они характеризуют некоторую сущность, то есть в данном сучае человека

// Объект - экземлпяр класса, обладает уже определенными значениями в характеристиках
// К примеру объект "Василий", это экземпляр класса "Человек". У данного экземпляра есть значения в характеристиках, то есть Имя - Вася, Фамилия - Пупкин, Возраст - 27, Вес - 70, Рост - 80

// Свойства - это все те характеристики Имя, Фамилия, Возраст, Вес, Рост

// Методы - это все те действия, которые может делать объект, к примеру Рисовать, Ходить, Кодить, Говорить


// Класс Прямоугольник
class Rectangle {
    // У класса есть свойства, ширина и высота
    width;
    height;

    // У каждого класса есть конструктор, это специальный метод, некоторый блок инструктций, который будет вызван при создании объекта. Он может принимать аргументы. Обычно в конструкторе свойствам объекта присваиваются какие то значения. В данном случае мы принимаем аргументами высоту и ширину, и сохраняем их
    constructor(w, h) {
        this.width = w;
        this.height = h;
    }

    // Так же есть метод для вычисления площади прямоугольника
    // В классах может быть сколько угодно методов
    calcArea() {
        // Под this, подразумевается объект у которого будет вызван этот метод
        return this.width * this.height;
    }

    calcPerimetr() {
        return (this.height + this.width) * 2;
    }
}

// С помощью оператора new, мы можем создать объект, то есть отдельный экземпляр класса.
// Передаем аргументами высоту и ширину
const rect = new Rectangle(5, 10);

// У созданного объекта, мы можем вызвать соответствующий метод, который вернет площадь объекта, у которого мы вызвали этот метод
rect.calcArea()

// Так же можно создать сколько угодно объектов из любого класса
// В данном примере, у каждого прямоугольника своя высота и ширина
const rect1 = new Rectangle(15, 20);
console.log("Area - rect1", rect1.calcArea());
console.log("Perimetr - rect1", rect1.calcPerimetr());

const rect2 = new Rectangle(25, 12);
console.log("Area - rect2", rect2.calcArea());
console.log("Perimetr - rect2", rect2.calcPerimetr());

const rect3 = new Rectangle(10, 42);
console.log("Area - rect3", rect3.calcArea());
console.log("Perimetr - rect3", rect3.calcPerimetr());



// ООП базируется на трех основных концепциях "Инкапсуляция", "Наследование", "Полиморфизм"
// Инкапсуляция - Класс, это своего рода капсула, которая хранит в себе свойства и методы для работы с этими самыми свойствами. То есть класс объединяет это все вместе.

// Сокрытие - К примеру возьмем класс "Человек", у этого класса есть такие свойства как "Имя", "Фамилия", "Возраст" и методы "Писать код", "Говорить", "Ходить", "Рисовать". Эти свойства и методы публичные, и их использование в любом месте кода, не нарушит логику программы.

// Помимо публичных свойств и методов есть закрытая часть, приватная. Это та часть с которой мы не можем работать и как то повлиять извне. К примеру класс "Человек", у человека есть приватные методы "Перекачивание крови", "Переваривание пищи", "Обработка информации", это скрытая часть, которая находится внутри человека, та часть на которую мы не можем повлиять как то извне.

// Существуют модификаторы доступа public и private, они позволяют делать свойства и методы публичными или приватными. Свойства и методы с модификатором private, можно использовать только внутри класса, вызвать их извне нельзя

// К примеру возьмем подключение к базе данных. В классе присутствую поля url и port. Для того что бы никто не смог поменять url, у этого свойства устанавливается модификатор доступа private. Единственный способ установки значения, это конструктор класса, то есть устанавливаем значения при создании экземпляра класса, и забываем

class Rectangle1 {
    // private ключевое слово, доступно в typescript
    // Теперь поля высоты и ширины приватные, обратиться к ним извне теперь нельзя
    // Нижнее подчеркивание, это соглашение между разработчиками, о том что данное поле приватное
    private _width;
    private _height;

    constructor(w, h) {
        this._width = w;
        this._height = h;
    }

    // Для того что бы получать доступ к этим свойствам (получать и изменять), используются геттеры и сеттеры
    // В данном случае, при вызове геттера, мы просто вернем ширину объекта
    get width() {
        // Внутри класса и методов, мы можем обращаться к приватным свойствам данного класса
        // this._height;
        return this._width;
    }

    // В случае с сеттером, мы можем присвоить новое значение, либо сделать дополнительные действия
    // Если явно не указывать модификатор доступа, он будет по умолчанию public
    set width(value) {
        if (value <= 0) {
            this._width = 1;
        } else {
            this._width = value;
        }
    }
}

const rect4 = new Rectangle1(5, 10);
// В данном случае мы не сможем обратиться к высоте, так как свойство приватное, и для него не созданы геттеры и сеттеры
// rect4.height();
console.log("Геттер", rect4.width());



// Пример
// Создание класса User
class User {
    // Объявление приватных свойств у класса
    private _username;
    private _password;
    private _id;

    // Имя и пароль мы получаем при создании эуземпляра класса
    constructor(username, password) {
        this.username = username;
        this.password = password;
        // this._id = generateRandomId();
    }

    // Для получения и изменения значений, создаем геттеры и сеттеры
    get username() {
        return this._username;
    }

    set username(value) {
        this._username = value;
    }

    get password() {
        return this._password;
    }

    set password(value) {
        this._password = value;
    }

    get id() {
        return this._id;
    }
}

// Создание экземпляра класса
const user = new User("username", "password");

// Ошибка, так как поле id доступно только для чтения
// user.id = 10;

// Так как мы создали сеттеры и геттеры, мы можем получить доступ к приватным свойствам
user.username = "user";
user.password = "123";



// Пример
// Создание класса
class Database {
    // Объявление приватных свойств
    private _url;
    private _port;
    private _username;
    private _password;
    private _tables;

    // Значения свойств мы присваиваем внутри конструктора
    constructor(url, port, username, password) {
        this._url = url;
        this._port = port;
        this._username = username;
        this._password = password;
        this._tables = [];
    }

    // Публичный метод, с помощью которого мы добавляем таблицы в массив
    public createNewTable(table) {
        this._tables.push(table);
    }

    // Публичный метод для удаления таблиц из массива
    public clearTables() {
        this._tables = [];
    }

    // Геттеры
    get url() {
        return this._url;
    }

    get port() {
        return this._port;
    }

    get username() {
        return this._username;
    }

    get password() {
        return this._password;
    }

    get tables() {
        return this._tables;
    }
}

// Создание экземпляра класса, в который мы передаем данные
const db = new Database(1, 2, 3, 4);

// Ошибка, приватное свойство
// db.tables = [];

// С помощью публичных методов, мы добавляем данные в массив
db.createNewTable({ "user": "1" });
db.createNewTable({ "data": "2" });

// Так же удаляем данные из массива
db.clearTables();

// Данные примеры показывают работу инкапсуляции и сокрытия. Они позволяют объявлять приватные свойства и методы, которые не доступны извне. Получение доступа к приватным свойствам с помощью геттеров и сеттеров.



// Наследование